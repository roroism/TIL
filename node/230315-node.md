# TODAY I LEARNED

## Learned

### call stack, non-blocking IO, event loop

> Node를 잘 이해하기 위해서는 자바스크립트의 동시성 모델에 대해 잘 이해해야 합니다.
> 자바스크립트의 실행 모델은 event loop, call stack, callback queue 개념으로 이루어집니다.

- 자바스크립트의 이벤트 루프 모델은 여러 스레드를 사용합니다.
- 그 중 우리가 작성한 자바스크립트 코드가 실행되는 스레드를 메인 스레드라 부릅니다.
- 한 Node.js 프로세스에서 메인 스레드는 하나이며, 한 순간에 한 줄씩만 실행합니다.
- 그러나 그 외의 일(file I/O, network로 입력을 받거나, network로 무언가를 보내는 등)을 하는 워커 스레드는 여럿이 있을 수 있습니다.

#### Call Stack

- 콜 스택이란, 지금 시점까지 불린 함수들의 스택입니다.
함수가 호출될 때 쌓이고, 리턴될 때 빠집니다.
- 이벤트 루프가 다음 콜백을 처리하려면 지금 처리하고 있는 콜백의 실행이 완전히 끝나야 합니다.
즉, call stack이 완전히 빌 때까지 처리한다는 것과 동일합니다.
이러한 자바스크립트 특성을 `Run-to-completion` 이라고합니다.

#### Callback Queue

- 콜백 큐(메세지 큐)는 앞으로 실행할 콜백(함수와 그 인자)들을 쌓아두는 큐입니다.
- 콜백은 브라우저나 Node가 어떤 일이 발생하면(event) 메인 스레드에 이를 알려주기 위해(callback) 사용됩니다.
- 이벤트는 파일 처리의 완료, 네트워크 작업의 완료, 타이머 호출 등이 있습니다.

#### non-blocking I/O & offloading

```javascript
// 여기서 Node에게 파일을 읽어달라고 요청하고, 워커 스레드에서 파일을 읽기 시작합니다.
fs.readFile(fileName, (err, data) => {
    // Node가 파일을 다 읽고 나면
    // 1. callback queue에 이 함수에 err, data 인자를 채워서 넣고
    // 2. callback queue에서 꺼내질 때 이 부분이 실행됩니다.
});

// readFile의 호출이 끝난 직후 바로 이 함수를 실행하게 됩니다.
// 이는 여전히 같은 콜백을 처리하는 중이기 때문입니다.
someTask();
```

- 브라우저나 Node.js에서나, Web API 혹은 Node API의 동작이 끝나면 callback queue에 등록합니다.
- 브라우저나 Node가 요청 받은 일을 하고 있는 동안 메인 스레드와 이벤트 루프는 영향을 받지 않고 계속 실행됩니다.
- 이러한 현상을 **offloading**이라고 하며, **Node 서버의 메인 스레드가 하나임에도 불구하고 빠르게 동작할 수 있는 이유**입니다. **메인 스레드가 오래 걸리는 일을 기다리지 않기 때문입니다.**

